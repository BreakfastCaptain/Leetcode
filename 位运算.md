# 位运算

## 原理

**基本原理**

0s 表示一串 0，1s 表示一串 1。

```
x ^ 0s = x      x & 0s = 0      x | 0s = x
x ^ 1s = ~x     x & 1s = x      x | 1s = 1s
x ^ x = 0       x & x = x       x | x = x
```

利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。

```
1^1^2 = 2
```

利用 x & 0s = 0 和 x & 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。

```
01011011 &
00111100
--------
00011000
```

利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。

```
01011011 |
00111100
--------
01111111
```

**位与运算技巧**

n&(n-1) 去除 n 的位级表示中最低的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。

```
01011011 &
01011010
--------
01011010
```

n&(-n) 得到 n 的位级表示中最低的那一位 1。***-n 得到 n 的反码加 1***，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。

```
10110100 &
01001100
--------
00000100
```

n-(n&(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&(n-1) 效果一样。

**移位运算**

\>\> n 为算术右移，相当于除以 2n，例如 -7 \>\> 2 = -2。

正数：即第一位是0，右移填充0

负数：即第一位是1，右移填充1

```
11111111111111111111111111111001  >> 2
--------
11111111111111111111111111111110
```

\>\>\> n 为无符号右移，左边会补上 0。例如 -7 \>\>\> 2 = 1073741822。

直接补0

```
11111111111111111111111111111001  >>> 2
--------
00111111111111111111111111111111
```

<< n 为算术左移，相当于乘以 2n。-7 << 2 = -28。

前面去掉几位，后面加上几个0

```
11111111111111111111111111111001  << 2
--------
11111111111111111111111111100100
```

**两数和**

```java
getSum((a ^ b), (a & b) << 1);
```

**mask 计算**

要获取 111111111，将 0 取反即可，~0。

要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1<<(i-1) 。例如 1<<4 得到只有第 5 位为 1 的 mask ：00010000。

要得到 1 到 i 位为 1 的 mask，(1<<i)-1 即可，例如将 (1<<4)-1 = 00010000-1 = 00001111。

要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1<<i)-1)。

**Java 中的位操作**

```
static int Integer.bitCount();           // 统计 1 的数量
static int Integer.highestOneBit();      // 获得最高位
static String toBinaryString(int i);     // 转换为二进制表示的字符串
```



## 461汉明距离:统计两个数的二进制表示有多少位不同

两个整数之间的 [汉明距离](https://baike.baidu.com/item/汉明距离) 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。

 

**示例 1：**

```
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
```

**示例 2：**

```
输入：x = 3, y = 1
输出：1
```

错误方法：用字符串对比判断

```java
public class _test {
    public static void main(String[] args) {
        int x = 1;
        int y = 4;
        String a = Integer.toBinaryString(x);
        String b = Integer.toBinaryString(y);
        int count = 0;
        for (int i = 0; i < a.length() && i < b.length(); i++) {
            if (a.charAt(i) != b.charAt(i)) {
                count++;
            }
        }
        System.out.println(a);
        System.out.println(b);
        System.out.println(count);
    }
}
// 1
// 100
// 0
```

对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。

```java
public int hammingDistance(int x, int y) {
    int z = x ^ y;
    // 异或操作，不同的位是1
    int cnt = 0;
    while(z != 0) {
        // z有1存在
        if ((z & 1) == 1) cnt++;
        // eg.1011&0001=0001,此目的在于验证最后一位是不是1，若是，则说明有一位不同
        z = z >>> 1;
        // 无符号右移，左边多出来的位置补上0
    }
    return cnt;
}
```

使用 z&(z-1) 去除 z 位级表示最低的那一位。

```java
public int hammingDistance(int x, int y) {
    int z = x ^ y;
    int cnt = 0;
    while (z != 0) {
        z &= (z - 1);
        // 去除n的位表示的最低的那一位1
        cnt++;
        // 只要有可以去掉的位数，便加1
    }
    return cnt;
}
```

可以使用 Integer.bitcount() 来统计 1 个的个数。

```java
public int hammingDistance(int x, int y) {
    return Integer.bitCount(x ^ y);
}
```



## 136数组中唯一一个不重复的元素

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

 

**示例 1 ：**

```
输入：nums = [2,2,1]
输出：1
```

**示例 2 ：**

```
输入：nums = [4,1,2,1,2]
输出：4
```

**示例 3 ：**

```
输入：nums = [1]
输出：1
```

try1

```java
class Solution {
    public int singleNumber(int[] nums) {
        int i=0;
        while(i<nums.length){
            int j=i+1,k=i;
            while(j<nums.length){
                if(nums[k]==nums[j]){
                    i++;
                }
                j++;
            }
            if(k==i)break;
            
        }
        return nums[i];            
        }

    }
// 缺少case1情况判断
输入：nums = [2,2,1]
输出：2
    实际：1
```

用位运算思想

两个相同的数异或的结果为 0，对所有数进行异或操作，最后的结果就是单独出现的那个数。

```java
public int singleNumber(int[] nums) {
    int ret = 0;
    for (int n : nums) ret = ret ^ n;
    /*利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。
1^1^2 = 2*/
    // x^0=x和ret初始值0进行异或不影响
    return ret;
}
```



## 268找出数组中缺失的那个数

给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。

**示例 1：**

```
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 2：**

```
输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 3：**

```
输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 4：**

```
输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
```

try1

```java
class Solution {
    public int missingNumber(int[] nums) {
        int k=0;
        for(int i=0;i<nums.length;i++){
            k+=nums[i];
        }
        return (1+nums.length)*nums.length/2-k;

    }
}
// 通过，但没用位运算
```

```java
public int missingNumber(int[] nums) {
    int ret = 0;
    for (int i = 0; i < nums.length; i++) {
        ret = ret ^ i ^ nums[i];
    }
    return ret ^ nums.length;
}
// 思路和找出单独的数相同，但是这里需要造出来重复的数，把0-n每一项都重复，即可找出缺失的数字
```

## 260数组中不重复的两个元素

给你一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。

你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

**示例 1：**

```
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
```

**示例 2：**

```
输入：nums = [-1,0]
输出：[-1,0]
```

**示例 3：**

```
输入：nums = [0,1]
输出：[1,0]
```

不清楚如何将最后剩余的两个数区分开来：

diff &= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。

```java
public int[] singleNumber(int[] nums) {
    int diff = 0;
    for (int num : nums) diff ^= num;
    diff &= -diff;  // 得到最右一位1
    // 异或，不同的位数都是1，所以最右边的一位1一定是两个数不同的位数
    int[] ret = new int[2];
    for (int num : nums) {
        if ((num & diff) == 0) ret[0] ^= num;
        // 这里其他符合条件的数因为是有重复所以也消掉了
        // 这里筛选出来那一位是0的
        else ret[1] ^= num;
        // 这里筛选出来那一位是1的
    }
    return ret;
}
```



## 190翻转一个数的比特位

颠倒给定的 32 位无符号整数的二进制位。

**提示：**

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/二进制补码/5295284)记法来表示有符号整数。因此，在 **示例 2** 中，输入表示有符号整数 `-3`，输出表示有符号整数 `-1073741825`。

**示例 1：**

```
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

**示例 2：**

```
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```

```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        // int 占用了4个字节，为32位，因而在二进制处理时即是32位对待
        int k=0;
        for(int i=0;i<32;i++){
            k<<1;
            // ret <<= 1;
            k=k|(n&1);
            // 复制该数的最后一位
            n>>>1;
        }
        return k;
        
    }
}
```

```java
public int reverseBits(int n) {
    int ret = 0;
    for (int i = 0; i < 32; i++) {
        ret <<= 1;
        ret |= (n & 1);
        n >>>= 1;
    }
    return ret;
}
```



## 不用额外变量交换两个整数

```java
a = a ^ b;
b = a ^ b;
// b=a^b^b=a
a = a ^ b;
// a=a^b^a=b
```



## 231判断一个数是不是 2 的 n 次方

给你一个整数 `n`，请你判断该整数是否是 2 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `x` 使得 `n == 2x` ，则认为 `n` 是 2 的幂次方。

**示例 1：**

```
输入：n = 1
输出：true
解释：20 = 1
```

**示例 2：**

```
输入：n = 16
输出：true
解释：24 = 16
```

```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n<=0) return false;
        int num1=0;
        for(int i=0;i<32;i++){
            if((n&1)==1) num1++;
            n>>>=1;
        }
        if(num1==1)return true;
        else return false;

    }
}
// 通过，排名较低
```

二进制表示只有一个 1 存在。

```java
public boolean isPowerOfTwo(int n) {
    return n > 0 && Integer.bitCount(n) == 1;
}
```

利用 1000 & 0111 == 0 这种性质，得到以下解法：

```java
public boolean isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
    // n&(n-1) 去除 n 的位级表示中最低的那一位 1。
}
```



## 342判断一个数是不是 4 的 n 次方

给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

整数 `n` 是 4 的幂次方需满足：存在整数 `x` 使得 `n == 4x`

**示例 1：**

```
输入：n = 16
输出：true
```

**示例 2：**

```
输入：n = 5
输出：false
```

**示例 3：**

```
输入：n = 1
输出：true
```

```java
// static int Integer.bitCount();           // 统计 1 的数量
// static int Integer.highestOneBit();      // 获得最高位
// 这个函数的作用是取 i 这个数的二进制形式最左边的最高一位且高位后面全部补零，最后返回int型的结果。


```

这种数在二进制表示中有且只有一个奇数位为 1，例如 16（10000）。

```java
public boolean isPowerOfFour(int num) {
    return num > 0 && (num & (num - 1)) == 0 && (num & 0b01010101010101010101010101010101) != 0;
    // Integer.bitCount(n) == 1;若第二项使用方法，则会降低速度，因而优先采用(num & (num - 1)) == 0，去除最低一位
    /* Java中数值变量的声明：
二进制变量的声明以0b为前缀；
八进制变量的声明以0为前缀；
十六进制变量的声明以0x为前缀。*/
}
```

也可以使用正则表达式进行匹配。

```java
public boolean isPowerOfFour(int num) {
    return Integer.toString(num, 4).matches("10*");
    /* public static String toString(int i, int radix)
将 int 转换为 String，以 radix 为进制
*/
}
```



## 693判断一个数的位级表示是否不会出现连续的 0 和 1

给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。

**示例 1：**

```
输入：n = 5
输出：true
解释：5 的二进制表示是：101
```

**示例 2：**

```
输入：n = 7
输出：false
解释：7 的二进制表示是：111.
```

**示例 3：**

```
输入：n = 11
输出：false
解释：11 的二进制表示是：1011.
```

对于 1010 这种位级表示的数，把它向右移动 1 位得到 101，这两个数每个位都不同，因此异或得到的结果为 1111。

```java
public boolean hasAlternatingBits(int n) {
    int a = (n ^ (n >> 1));
    // 若正确，无论如何1*
    return (a & (a + 1)) == 0;
    // 10*与01*
}
```



## 476求一个数的补数

对整数的二进制表示取反（`0` 变 `1` ，`1` 变 `0`）后，再转换为十进制表示，可以得到这个整数的补数。

- 例如，整数 `5` 的二进制表示是 `"101"` ，取反后得到 `"010"` ，再转回十进制表示得到补数 `2` 。

给你一个整数 `num` ，输出它的补数。

**示例 1：**

```
输入：num = 5
输出：2
解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
```

**示例 2：**

```
输入：num = 1
输出：0
解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
```

利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转；

static int Integer.highestOneBit();      // 获得最高位

```java
class Solution {
    public int findComplement(int num) {
        int high=Integer.highestOneBit(num);
        int ones=high*2-1;
        int ans=num^ones;
        return ans;

    }
}
// 自己写出通过，前提需要对于上面两个熟悉

```

对于 10000000 这样的数要扩展成 11111111，可以利用以下方法：

```java
mask |= mask >> 1    11000000
mask |= mask >> 2    11110000
mask |= mask >> 4    11111111
public int findComplement(int num) {
    int mask = num; // 101101101
    mask |= mask >> 1;// 101101101 | 010110110 = 111111111
    mask |= mask >> 2;
    mask |= mask >> 4;
    mask |= mask >> 8;
    mask |= mask >> 16;
    return (mask ^ num);// 利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转；
}
```



## 371实现整数的加法

给你两个整数 `a` 和 `b` ，**不使用** 运算符 `+` 和 `-` ，计算并返回两整数之和。

**示例 1：**

```
输入：a = 1, b = 2
输出：3
```

**示例 2：**

```
输入：a = 2, b = 3
输出：5
```

**a ^ b 表示没有考虑进位的情况下两数的和**，**(a & b) << 1 就是进位**。

递归会终止的原因是 (a & b) << 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。

```java
public int getSum(int a, int b) {
    return b == 0 ? a : getSum((a ^ b), (a & b) << 1);
    // 这里(a & b) << 1表示一次左移之后的结果，<<=1一般用在循环语句中
    // ?含义if(b==0)return a; else return getSum();
}
```



## 318字符串数组最大乘积

给你一个字符串数组 `words` ，找出并返回 `length(words[i]) * length(words[j])` 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 `0` 。

**示例 1：**

```
输入：words = ["abcw","baz","foo","bar","xtfn","abcdef"]
输出：16 
解释：这两个单词为 "abcw", "xtfn"。
```

**示例 2：**

```
输入：words = ["a","ab","abc","d","cd","bcd","abcd"]
输出：4 
解释：这两个单词为 "ab", "cd"。
```

**示例 3：**

```
输入：words = ["a","aa","aaa","aaaa"]
输出：0 
解释：不存在这样的两个单词。
```

本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数来存储每个字符是否出现过。

```java
public int maxProduct(String[] words) {
    int n = words.length;
    int[] val = new int[n];
    // 创建字符串组长度相同的数组
    for (int i = 0; i < n; i++) {
        for (char c : words[i].toCharArray()) {
            // 每一个单词的每一个字母循环
            val[i] |= 1 << (c - 'a');
            // 算数运算符>移位运算符>条件运算符>按位运算符>逻辑运算符>赋值
            // (c - 'a')将字母转化为数字。。1向左移动这个数字，即记录了这个字母所代表的位置，之后val[i]代表的是这个单词的所出现所有的字符
        }
    }
    int ret = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if ((val[i] & val[j]) == 0) {
                // if(val[i]==val[j])错写成：这里的含义是如果二者相同才通过
                // 两个单词没有重复字符
                ret = Math.max(ret, words[i].length() * words[j].length());
                // ans=Math.max(ans,words[i].length*words[j].length);错误
                /* length()和length区别：
                在java中String类可以定义字符串变量和字符串数组，length()用于求String字符串对象的长度，而length用于求String字符串数组的长度。*/
            }
        }
    }
    return ret;
}
// 思想：直接用单词比较然后判断是否有重复字符不容易处理，转化为数组形式，利用位运算给每个字母固定位置，交集判断是否有重复字母
```



## 338统计从 0 ~ n 每个数的二进制表示中 1 的个数

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**示例 1：**

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

**示例 2：**

```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

```java
class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n+1];
        for(int i=0;i<=n;i++){
            ans[i]=Integer.bitCount(i);
        }
return ans;
    }
}
```

不使用内置函数：

对于数字 6(110)，它可以看成是 4(100) 再加一个 2(10)，因此 dp[i] = dp[i&(i-1)] + 1;

定义正整数 x 的「最低设置位」为 x 的二进制表示中的最低的 1 所在位。例如，10的二进制表示是 1010(2)，最低位设置为2.

令 y=x & (x−1)，则 y 为将 x 的最低设置位从 1 变成 0 之后的数（之前最低位1前面的数都不变），显然 0≤y<x ，改变之后少了一个1，bits[x]=bits[y]+1。因此对任意正整数 x，都有 bits[x]=bits[x & (x−1)]+1

遍历从 1 到 n 的每个正整数 i，计算 bits 的值。最终得到的数组 bits 即为答案。



```java
public int[] countBits(int num) {
    int[] ret = new int[num + 1];
    for(int i = 1; i <= num; i++){
        ret[i] = ret[i&(i-1)] + 1;
    }
    return ret;
}
```
